{"ast":null,"code":"import \"react\";\n\nconst checkValidation = (name, stateName, type, validations, onValidationError, stateObj) => {\n  let errorMessage = \"\";\n  const fieldValue = stateObj[stateName];\n\n  if (!fieldValue || type !== \"password\" && !fieldValue.trim()) {\n    errorMessage = \"\".concat(name, \" cant be empty\");\n  } else if (validations && validations.length) {\n    validations.reverse().forEach(validation => {\n      const type = validation.type,\n            value = validation.value,\n            error = validation.error,\n            otherStateName = validation.otherStateName,\n            otherFieldName = validation.otherFieldName;\n\n      if (type === \"regex\" && !fieldValue.match(value)) {\n        errorMessage = \"invalid \".concat(name, \", \").concat(error);\n      } else if (type === \"minLength\" && fieldValue.length < value) {\n        errorMessage = \"\".concat(name, \" should have atleast \").concat(value, \" characters\");\n      } else if (type === \"equalToOtherField\" && fieldValue !== stateObj[otherStateName]) {\n        errorMessage = \"\".concat(name, \" should match to \").concat(otherFieldName);\n      } else {\n        errorMessage = \"\";\n      }\n    });\n  }\n\n  return onValidationError({\n    stateName,\n    errorMessage\n  });\n};\n\nconst validateEntireDataset = (fields = [], stateObj) => {\n  let errors = stateObj.errors;\n  if (!fields.length) return {};\n  fields.forEach(fieldSpec => {\n    const stateName = fieldSpec.stateName;\n    const fieldName = fieldSpec.name;\n    const fieldValue = stateObj[stateName];\n\n    if (fieldSpec.isRequired) {\n      // required field error\n      if (!fieldValue || fieldSpec.type === \"password\" && !fieldValue.trim()) {\n        errors[stateName] = \"\".concat(fieldName, \" cant be empty\");\n      } else errors[stateName] = \"\";\n    }\n\n    if (fieldValue && fieldSpec.validations && fieldSpec.validations.length) {\n      fieldSpec.validations.reverse().forEach(validation => {\n        const type = validation.type,\n              value = validation.value,\n              error = validation.error,\n              otherStateName = validation.otherStateName,\n              otherFieldName = validation.otherFieldName;\n\n        if (type === \"regex\" && !fieldValue.match(value)) {\n          errors[stateName] = \"invalid \".concat(fieldName, \", \").concat(error);\n        } else if (type === \"minLength\" && fieldValue.length < value) {\n          errors[stateName] = \"\".concat(fieldName, \" should have atleast \").concat(value, \" characters\");\n        } else if (type === \"equalToOtherField\" && fieldValue !== stateObj[otherStateName]) {\n          errors[stateName] = \"\".concat(fieldName, \" should match to \").concat(otherFieldName);\n        } else {\n          errors[stateName] = \"\";\n        }\n      });\n    }\n  });\n  return errors;\n};\n\nexport default {\n  checkValidation,\n  validateEntireDataset\n};","map":{"version":3,"sources":["D:/work/react_login/office/src/utils.js"],"names":["checkValidation","name","stateName","type","validations","onValidationError","stateObj","errorMessage","fieldValue","trim","length","reverse","forEach","validation","value","error","otherStateName","otherFieldName","match","validateEntireDataset","fields","errors","fieldSpec","fieldName","isRequired"],"mappings":"AAAA,OAAO,OAAP;;AACA,MAAMA,eAAe,GAAG,CACtBC,IADsB,EAEtBC,SAFsB,EAGtBC,IAHsB,EAItBC,WAJsB,EAKtBC,iBALsB,EAMtBC,QANsB,KAOnB;AACH,MAAIC,YAAY,GAAG,EAAnB;AACA,QAAMC,UAAU,GAAGF,QAAQ,CAACJ,SAAD,CAA3B;;AACA,MAAI,CAACM,UAAD,IAAgBL,IAAI,KAAK,UAAT,IAAuB,CAACK,UAAU,CAACC,IAAX,EAA5C,EAAgE;AAC9DF,IAAAA,YAAY,aAAMN,IAAN,mBAAZ;AACD,GAFD,MAEO,IAAIG,WAAW,IAAIA,WAAW,CAACM,MAA/B,EAAuC;AAC5CN,IAAAA,WAAW,CAACO,OAAZ,GAAsBC,OAAtB,CAA8BC,UAAU,IAAI;AAAA,YAClCV,IADkC,GACqBU,UADrB,CAClCV,IADkC;AAAA,YAC5BW,KAD4B,GACqBD,UADrB,CAC5BC,KAD4B;AAAA,YACrBC,KADqB,GACqBF,UADrB,CACrBE,KADqB;AAAA,YACdC,cADc,GACqBH,UADrB,CACdG,cADc;AAAA,YACEC,cADF,GACqBJ,UADrB,CACEI,cADF;;AAG1C,UAAId,IAAI,KAAK,OAAT,IAAoB,CAACK,UAAU,CAACU,KAAX,CAAiBJ,KAAjB,CAAzB,EAAkD;AAChDP,QAAAA,YAAY,qBAAcN,IAAd,eAAuBc,KAAvB,CAAZ;AACD,OAFD,MAEO,IAAIZ,IAAI,KAAK,WAAT,IAAwBK,UAAU,CAACE,MAAX,GAAoBI,KAAhD,EAAuD;AAC5DP,QAAAA,YAAY,aAAMN,IAAN,kCAAkCa,KAAlC,gBAAZ;AACD,OAFM,MAEA,IACLX,IAAI,KAAK,mBAAT,IACAK,UAAU,KAAKF,QAAQ,CAACU,cAAD,CAFlB,EAGL;AACAT,QAAAA,YAAY,aAAMN,IAAN,8BAA8BgB,cAA9B,CAAZ;AACD,OALM,MAKA;AACLV,QAAAA,YAAY,KAAZ;AACD;AACF,KAfD;AAgBD;;AACD,SAAOF,iBAAiB,CAAC;AAAEH,IAAAA,SAAF;AAAaK,IAAAA;AAAb,GAAD,CAAxB;AACD,CA/BD;;AAiCA,MAAMY,qBAAqB,GAAG,CAACC,MAAM,GAAG,EAAV,EAAcd,QAAd,KAA2B;AACvD,MAAIe,MAAM,GAAGf,QAAQ,CAACe,MAAtB;AACA,MAAI,CAACD,MAAM,CAACV,MAAZ,EAAoB,OAAO,EAAP;AACpBU,EAAAA,MAAM,CAACR,OAAP,CAAeU,SAAS,IAAI;AAC1B,UAAMpB,SAAS,GAAGoB,SAAS,CAACpB,SAA5B;AACA,UAAMqB,SAAS,GAAGD,SAAS,CAACrB,IAA5B;AACA,UAAMO,UAAU,GAAGF,QAAQ,CAACJ,SAAD,CAA3B;;AACA,QAAIoB,SAAS,CAACE,UAAd,EAA0B;AACxB;AACA,UACE,CAAChB,UAAD,IACCc,SAAS,CAACnB,IAAV,KAAmB,UAAnB,IAAiC,CAACK,UAAU,CAACC,IAAX,EAFrC,EAGE;AACAY,QAAAA,MAAM,CAACnB,SAAD,CAAN,aAAuBqB,SAAvB;AACD,OALD,MAKOF,MAAM,CAACnB,SAAD,CAAN,GAAoB,EAApB;AACR;;AACD,QAAIM,UAAU,IAAIc,SAAS,CAAClB,WAAxB,IAAuCkB,SAAS,CAAClB,WAAV,CAAsBM,MAAjE,EAAyE;AACvEY,MAAAA,SAAS,CAAClB,WAAV,CAAsBO,OAAtB,GAAgCC,OAAhC,CAAwCC,UAAU,IAAI;AAAA,cAElDV,IAFkD,GAOhDU,UAPgD,CAElDV,IAFkD;AAAA,cAGlDW,KAHkD,GAOhDD,UAPgD,CAGlDC,KAHkD;AAAA,cAIlDC,KAJkD,GAOhDF,UAPgD,CAIlDE,KAJkD;AAAA,cAKlDC,cALkD,GAOhDH,UAPgD,CAKlDG,cALkD;AAAA,cAMlDC,cANkD,GAOhDJ,UAPgD,CAMlDI,cANkD;;AASpD,YAAId,IAAI,KAAK,OAAT,IAAoB,CAACK,UAAU,CAACU,KAAX,CAAiBJ,KAAjB,CAAzB,EAAkD;AAChDO,UAAAA,MAAM,CAACnB,SAAD,CAAN,qBAA+BqB,SAA/B,eAA6CR,KAA7C;AACD,SAFD,MAEO,IAAIZ,IAAI,KAAK,WAAT,IAAwBK,UAAU,CAACE,MAAX,GAAoBI,KAAhD,EAAuD;AAC5DO,UAAAA,MAAM,CACJnB,SADI,CAAN,aAEOqB,SAFP,kCAEwCT,KAFxC;AAGD,SAJM,MAIA,IACLX,IAAI,KAAK,mBAAT,IACAK,UAAU,KAAKF,QAAQ,CAACU,cAAD,CAFlB,EAGL;AACAK,UAAAA,MAAM,CAACnB,SAAD,CAAN,aAAuBqB,SAAvB,8BAAoDN,cAApD;AACD,SALM,MAKA;AACLI,UAAAA,MAAM,CAACnB,SAAD,CAAN;AACD;AACF,OAvBD;AAwBD;AACF,GAvCD;AAwCA,SAAOmB,MAAP;AACD,CA5CD;;AA6CA,eAAe;AACbrB,EAAAA,eADa;AAEbmB,EAAAA;AAFa,CAAf","sourcesContent":["import \"react\";\r\nconst checkValidation = (\r\n  name,\r\n  stateName,\r\n  type,\r\n  validations,\r\n  onValidationError,\r\n  stateObj\r\n) => {\r\n  let errorMessage = \"\";\r\n  const fieldValue = stateObj[stateName];\r\n  if (!fieldValue || (type !== \"password\" && !fieldValue.trim())) {\r\n    errorMessage = `${name} cant be empty`;\r\n  } else if (validations && validations.length) {\r\n    validations.reverse().forEach(validation => {\r\n      const { type, value, error, otherStateName, otherFieldName } = validation;\r\n\r\n      if (type === \"regex\" && !fieldValue.match(value)) {\r\n        errorMessage = `invalid ${name}, ${error}`;\r\n      } else if (type === \"minLength\" && fieldValue.length < value) {\r\n        errorMessage = `${name} should have atleast ${value} characters`;\r\n      } else if (\r\n        type === \"equalToOtherField\" &&\r\n        fieldValue !== stateObj[otherStateName]\r\n      ) {\r\n        errorMessage = `${name} should match to ${otherFieldName}`;\r\n      } else {\r\n        errorMessage = ``;\r\n      }\r\n    });\r\n  }\r\n  return onValidationError({ stateName, errorMessage });\r\n};\r\n\r\nconst validateEntireDataset = (fields = [], stateObj) => {\r\n  let errors = stateObj.errors;\r\n  if (!fields.length) return {};\r\n  fields.forEach(fieldSpec => {\r\n    const stateName = fieldSpec.stateName;\r\n    const fieldName = fieldSpec.name;\r\n    const fieldValue = stateObj[stateName];\r\n    if (fieldSpec.isRequired) {\r\n      // required field error\r\n      if (\r\n        !fieldValue ||\r\n        (fieldSpec.type === \"password\" && !fieldValue.trim())\r\n      ) {\r\n        errors[stateName] = `${fieldName} cant be empty`;\r\n      } else errors[stateName] = \"\";\r\n    }\r\n    if (fieldValue && fieldSpec.validations && fieldSpec.validations.length) {\r\n      fieldSpec.validations.reverse().forEach(validation => {\r\n        const {\r\n          type,\r\n          value,\r\n          error,\r\n          otherStateName,\r\n          otherFieldName\r\n        } = validation;\r\n\r\n        if (type === \"regex\" && !fieldValue.match(value)) {\r\n          errors[stateName] = `invalid ${fieldName}, ${error}`;\r\n        } else if (type === \"minLength\" && fieldValue.length < value) {\r\n          errors[\r\n            stateName\r\n          ] = `${fieldName} should have atleast ${value} characters`;\r\n        } else if (\r\n          type === \"equalToOtherField\" &&\r\n          fieldValue !== stateObj[otherStateName]\r\n        ) {\r\n          errors[stateName] = `${fieldName} should match to ${otherFieldName}`;\r\n        } else {\r\n          errors[stateName] = ``;\r\n        }\r\n      });\r\n    }\r\n  });\r\n  return errors;\r\n};\r\nexport default {\r\n  checkValidation,\r\n  validateEntireDataset\r\n};\r\n"]},"metadata":{},"sourceType":"module"}