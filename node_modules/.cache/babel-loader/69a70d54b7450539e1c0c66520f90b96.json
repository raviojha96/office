{"ast":null,"code":"import 'react';\n\nconst checkValidation = (name, stateName, type, validations, onValidationError, stateObj) => {\n  let errorMessage = \"\";\n  const fieldValue = stateObj[stateName];\n\n  if (!fieldValue || type !== \"password\" && !fieldValue.trim()) {\n    errorMessage = \"\".concat(name, \" cant be empty\");\n  } else if (validations && validations.length) {\n    validations.reverse().forEach(validation => {\n      const type = validation.type,\n            value = validation.value,\n            error = validation.error,\n            otherStateName = validation.otherStateName,\n            otherFieldName = validation.otherFieldName;\n\n      if (type === \"regex\" && !fieldValue.match(value)) {\n        errorMessage = \"invalid \".concat(name, \", \").concat(error);\n      } else if (type === \"minLength\" && fieldValue.length < value) {\n        errorMessage = \"\".concat(name, \" should have atleast \").concat(value, \" characters\");\n      } else if (type === \"equalToOtherField\" && fieldValue !== stateObj[otherStateName]) {\n        errorMessage = \"\".concat(name, \" should match to \").concat(otherFieldName);\n      } else {\n        errorMessage = \"\";\n      }\n    });\n  }\n\n  return onValidationError({\n    stateName,\n    errorMessage\n  });\n};\n\nconst validateEntireDataset = (fields = [], stateObj) => {\n  let errors = stateObj.errors;\n  if (!fields.length) return {};\n  fields.forEach(fieldSpec => {\n    const stateName = fieldSpec.stateName;\n    const fieldName = fieldSpec.name;\n    const fieldValue = stateObj[stateName];\n\n    if (fieldSpec.isRequired) {\n      // required field error\n      if (!fieldValue || fieldSpec.type === \"password\" && !fieldValue.trim()) {\n        errors[stateName] = \"\".concat(fieldName, \" cant be empty\");\n      } else errors[stateName] = '';\n    }\n\n    if (fieldValue && fieldSpec.validations && fieldSpec.validations.length) {\n      fieldSpec.validations.reverse().forEach(validation => {\n        const type = validation.type,\n              value = validation.value,\n              error = validation.error,\n              otherStateName = validation.otherStateName,\n              otherFieldName = validation.otherFieldName;\n\n        if (type === \"regex\" && !fieldValue.match(value)) {\n          errors[stateName] = \"invalid \".concat(fieldName, \", \").concat(error);\n        } else if (type === \"minLength\" && fieldValue.length < value) {\n          errors[stateName] = \"\".concat(fieldName, \" should have atleast \").concat(value, \" characters\");\n        } else if (type === \"equalToOtherField\" && fieldValue !== stateObj[otherStateName]) {\n          errors[stateName] = \"\".concat(fieldName, \" should match to \").concat(otherFieldName);\n        } else {\n          errors[stateName] = \"\";\n        }\n      });\n    }\n  });\n  return errors;\n};\n\nexport default {\n  checkValidation,\n  validateEntireDataset\n};","map":{"version":3,"sources":["D:/work/react_login/office/src/utils.js"],"names":["checkValidation","name","stateName","type","validations","onValidationError","stateObj","errorMessage","fieldValue","trim","length","reverse","forEach","validation","value","error","otherStateName","otherFieldName","match","validateEntireDataset","fields","errors","fieldSpec","fieldName","isRequired"],"mappings":"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","sourcesContent":["import 'react';\r\nconst checkValidation = (name, stateName, type, validations, onValidationError, stateObj) => {\r\n    let errorMessage = \"\";\r\n    const fieldValue = stateObj[stateName];\r\n    if (!fieldValue || (type !== \"password\" && !fieldValue.trim())) {\r\n        errorMessage = `${name} cant be empty`;\r\n    }\r\n    else if (validations && validations.length) {\r\n        validations.reverse().forEach(validation => {\r\n            const { type, value, error, otherStateName, otherFieldName } = validation;\r\n\r\n            if (type === \"regex\" && !fieldValue.match(value)) {\r\n                errorMessage = `invalid ${name}, ${error}`;\r\n            } else if (type === \"minLength\" && fieldValue.length < value) {\r\n                errorMessage = `${name} should have atleast ${value} characters`;\r\n            } else if (type === \"equalToOtherField\" && fieldValue !== stateObj[otherStateName]) {\r\n                errorMessage = `${name} should match to ${otherFieldName}`;\r\n            } else {\r\n                errorMessage = ``;\r\n            }\r\n            \r\n        });\r\n    }\r\n    return onValidationError({ stateName, errorMessage });\r\n};\r\n\r\nconst validateEntireDataset = (fields = [], stateObj) => {\r\n    let errors = stateObj.errors;\r\n    if (!fields.length) return {};\r\n    fields.forEach(fieldSpec => {\r\n        const stateName = fieldSpec.stateName;\r\n        const fieldName = fieldSpec.name;\r\n        const fieldValue = stateObj[stateName];\r\n        if (fieldSpec.isRequired) { // required field error\r\n            if (!fieldValue || (fieldSpec.type === \"password\" && !fieldValue.trim())) {\r\n                errors[stateName] = `${fieldName} cant be empty`;\r\n            }\r\n            else errors[stateName] = '';\r\n        }\r\n        if (fieldValue && fieldSpec.validations && fieldSpec.validations.length) {\r\n            fieldSpec.validations.reverse().forEach(validation => {\r\n                const { type, value, error, otherStateName, otherFieldName } = validation;\r\n\r\n                if (type === \"regex\" && !fieldValue.match(value)) {\r\n                    errors[stateName] = `invalid ${fieldName}, ${error}`;\r\n                } else if (type === \"minLength\" && fieldValue.length < value) {\r\n                    errors[stateName] = `${fieldName} should have atleast ${value} characters`;\r\n                } else if (type === \"equalToOtherField\" && fieldValue !== stateObj[otherStateName]) {\r\n                    errors[stateName] = `${fieldName} should match to ${otherFieldName}`;\r\n                } else {\r\n                    errors[stateName] = ``;\r\n                }\r\n            });\r\n        }\r\n    })\r\n    return errors;\r\n}\r\nexport default {\r\n    checkValidation,\r\n    validateEntireDataset\r\n}\r\n"]},"metadata":{},"sourceType":"module"}